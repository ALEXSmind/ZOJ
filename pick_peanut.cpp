/*
采花生

时间限制 1000 ms 内存限制 16384 KB 代码长度限制 100 KB 判断程序 Standard (来自 小小)
题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！——熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说:“你先找出花生最多的植株，去采摘它的花生;然后再找出剩下的植株里花生最多的，去采摘它的花生;依此类推，不过你一定要在我限定的时间内回到路边。”

我们假定多多在每个单位时间内,可以做下列四件事情中的一件：

1. 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2. 从一棵植株跳到前后左右与之相邻的另一棵植株；
3. 采摘一棵植株下的花生；
4. 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？

注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。例如花生田里只有位于(2, 5), (3, 7), (4, 2), (5, 4)的植株下长有花生，个数分别为 13, 7, 15, 9。多多在 21 个单位时间内，只能经过(4, 2)、(2, 5)、(5, 4)，最多可以采到 37 个花生。


输入描述:

输入包含多组数据，每组数据第一行包括三个整数 M（1≤M≤20）、N（1≤N≤20）和 K（0≤K≤1000），用空格隔开；表示花生田的大小为 M * N，多多采花生的限定时间为 K个单位时间。

紧接着 M 行，每行包括 N 个自然数 P（0≤P≤500），用空格隔开；表示花生田里植株下花生的数目，并且除了0（没有花生），其他所有植株下花生的数目都不相同。



输出描述:

对应每一组数据，输出一个整数，即在限定时间内，多多最多可以采到花生的个数。


输入例子:

6 7 21
0 	0 	0 	0 	0 	0 	0
0 	0 	0 	0 	13 	0 	0
0 	0 	0 	0 	0 	0 	7
0 	15 	0 	0 	0 	0 	0
0 	0 	0 	9 	0 	0 	0
0 	0 	0 	0 	0 	0 	0


输出例子:

37
*/

#include <iostream>
#include <cmath>
using namespace std;

void quick_sort(int s[], int l, int r)  
{  
    if (l < r)  
    {  
        //Swap(s[l], s[(l + r) / 2]); //将中间的这个数和第一个数交换 参见注1  
        int i = l, j = r, x = s[l];  
        while (i < j)  
        {  
            while(i < j && s[j] <= x) // 从右向左找第一个小于x的数  
                j--;    
            if(i < j)   
                s[i++] = s[j];  
              
            while(i < j && s[i] > x) // 从左向右找第一个大于等于x的数  
                i++;    
            if(i < j)   
                s[j--] = s[i];  
        }  
        s[i] = x;  
        quick_sort(s, l, i - 1); // 递归调用   
        quick_sort(s, i + 1, r);  
    }  
} 

int work_out(int m,  int n, int k)
{
	int a[m][n],count,temp,b[m*n],bm[m*n],bn[m*n],b1[m*n],step;
	count = 0;
	temp = 0;
	 for (int i =  0; i < m*n; i++)
    {
		b[i] = bm[i] = bn[i] = b1[i] =0;
	}
    for (int i =  0; i < m; i++)
    {
		for (int j = 0; j < n; j++)
		{
			cin >> a[i][j];
			if(a[i][j] > 0)
			{
				b[temp] = a[i][j];
				b1[temp] = a[i][j];
				bm[temp] = i;
				bn[temp] = j;
				temp++;
			}
		}
	}

	quick_sort(&b1[0],0,temp-1);

	for(int i = 0; i < temp; i++)
	{
		for(int j =0; j < temp; j++)
		{
			if(b1[i] == b[j])
			{
				b1[i] = j;
				break;
			}
		}
	}

	if(bm[b1[0]]*2 +1 <= k)
	{
		count = b[b1[0]];
		step =  bm[b1[0]] +1;

		for(int i = 1; i < temp; i++)
		{
			if(step + abs(bm[b1[i-1]] -bm[b1[i]]) + abs(bn[b1[i-1]] -bn[b1[i]]) + bm[b1[i]] + 1 <= k)
			{
				count += b[b1[i]];
				step =  step + abs(bm[b1[i-1]] -bm[b1[i]]) + abs(bn[b1[i-1]] -bn[b1[i]]) +1;
			}
			else
				break;
		}
	}
	
	return count;
}

int main()
{
    int m,n,k,count;
    cin >> m >> n >> k;
	count = work_out(m,n,k);
	cout << count << endl;
}
